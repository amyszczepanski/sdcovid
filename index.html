<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>San Diego County: COVID-19</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.25.0/moment.min.js" integrity="sha256-imB/oMaNA0YvIkDkF5mINRWpuFPEGVCEkHy6rm2lAzA=" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
		<script src="zipShapes.js"></script>
		<style type="text/css">
			html, body {
				font-family: Helvetica, sans-serif;
				height: auto;
				max-width: 100%;
				padding-left: 10px;
      }
      .map-box {
				max-width: 100%;
      }
      svg {
      	margin: 10px;
      	padding: 10px;
      }
      ul.data-list {
      	margin-bottom: 25px;
      }
		</style>
	</head>
	<body>
		<div><h2>Some data on COVID-19 in San Diego County</h2>
		<div id="overall-stats" style="visibility: hidden">Waiting for data...<br>Loading...</div>
		<div><h3>Rate of positive COVID-19 tests each day in San Diego County</h3></div>
		<div id="positive-words">Early dates have incomplete data.</div>
		<div id="positive-graph"></div>
		<div><h3>Cumulative rate of positive COVID-19 tests in San Diego County</h3></div>
		<div id="cumPositive-words"></div>
		<div id="cumPositive-graph"></div>
		<div><h3>COVID-19 total cases in San Diego County by ZIP code</h3></div>
		<div style="padding-bottom: 10px;">
			<label for="zipDate">Data available after March 30, 2020. Pick a valid date:</label>
			<input type="date" id="zipDate" name="zipDate" />
		</div>
		<div>Grayscale for locations with fewer than five cases or fewer than 10,000 people.</div>
		<div style="padding-bottom: 5px;">Darker colors represent more cases per 10,000 population.</div>
		<div id="words"></div>
		<div id="map" class="map-box"></div>
		<div style="padding-bottom: 10px;">Some data for military bases is reported inconsistently.</div>
		<div>
			Data sources:
			<ul class="data-list">
				<li>
						<a href="http://sdgis-sandag.opendata.arcgis.com/datasets/zip-code">ZIP
						code boundaries</a> from SANDAG SanGIS.
				</li>
				<li>
						ZIP code population data from <a href="http://datasurfer.sandag.org">
				    SANDAG Data Surfer</a> (2018 estimates).
				</li>
				<li>
						<a href="http://sdgis-sandag.opendata.arcgis.com/datasets/covid-19-statistics-by-zip-code">
						COVID-19 Statistics by ZIP Code</a> from SANDAG SanGIS.
				</li>
				<li>
					<a href="https://sdgis-sandag.opendata.arcgis.com/datasets/covid-19-statistics-san-diego-county">
					COVID-19 testing rates</a> from SANDAG SanGIS.
				</li>
			</ul>
		</div>

		<script type="text/javascript">
		  const MAX_POPULATION = 84626;

			// Note to self, County doesn't use WGS84.
			// ogr2ogr -f GeoJSON -t_srs "EPSG:4326" zipcodes.geojson f285f663-2fc3-43b8-910a-31df89a27bdf2020330-1-1a4uvc4.5829.shp

			// Width and height of SVG for map
			const w = 800;
			const h = 600;
			
			// Height for positive rate - doesn't need to be as tall
			const hPositive = 200;
			const paddingPos = 40;
			
			// Create SVG element for the positive tests
			const positivesvg = d3.select("#positive-graph")
				.append("svg")
				.attr("width", w)
				.attr("height", hPositive)

			// Create SVG element for the cumulative positive tests
			const cumPositivesvg = d3.select("#cumPositive-graph")
				.append("svg")
				.attr("width", w)
				.attr("height", hPositive)

			//Create SVG element for the map
			const mapsvg = d3.select("#map")
				.append("svg")
				.attr("width", w)
				.attr("height", h);
				
			// Loading...
			positivesvg.append("text")
				.attr("id", "pos-loading-text")
				.attr("x",20).attr("y",20)
				.text("Loading...");

			cumPositivesvg.append("text")
				.attr("id", "cp-loading-text")
				.attr("x",20).attr("y",20)
				.text("Loading...");

			mapsvg.append("text")
				.attr("id", "map-loading-text")
				.attr("x",20).attr("y",20)
				.text("Loading...");

			const tooltip = d3
				.select("html")
				.append("div")
				.attr("class", "tooltip")
				.style("opacity", 0)
				.style("background-color", "white")
				.style("border", "solid")
				.style("border-width", "1px")
				.style("border-radius", "3px")
				.style("padding", "4px")
				.style("pointer-events", "none");

				// ad hoc way of fixing tooltips on mobile
				document.body.addEventListener("click", function() {
					if (this.className === "ZIP" || this.className === "point" || this.className === "tooltip") {
						return;
					} else {
						d3.selectAll("div.tooltip")
						  .style("opacity", 0);
// 						console.log("I obliterate tooltips.");
						return;
					}
				});

				// Helper functions and such
				
				// This should go into the zipShapes.js file.
				const objectZIP = {};
				// Match data to shapes based on OBJECTID from the GeoJSON
				for (let i = 0; i < zipShapes.features.length; i++) {
					theZIP = zipShapes.features[i].properties.ZIP.toString();					
					if (theZIP in objectZIP) {
						objectZIP[theZIP].push(i);		
					} else {
						objectZIP[theZIP] = [i];
					}
				}
				
				// Simplify the data structure.
				const processCountyData = function(countyData) {
					// Array of objects makes it easier to find the extent of the data
					const dateCounts = [];
					for (let i = 0; i < countyData.features.length; i++) {
						const thisZIP = countyData.features[i].properties.zipcode_zip;
						const updateDate = countyData.features[i].properties.updatedate;
						const caseCount = countyData.features[i].properties.case_count;
						const parsedDate = moment(updateDate, "YYYY-MM-DD");
						dateCounts.push({"ZIP": thisZIP.toString(), "date": parsedDate, "cases": caseCount});
					}
					return dateCounts;
				}

				// We can map for any date in the dataset by looking up (date, object)
				// The shapefile has the object for each path; OBJECTID = index + 1
				const makeMappableData = function(minDate, dateExtent, dateCounts, objectZIP) {
					// This creates the array of arrays that can be used for mapping
					// (dateOffset, cases[objectID]) 
					casesDateZIP = [];
					for (let i = 0; i < dateExtent + 1; i++) {
						casesDateZIP.push(Array(zipShapes.features.length).fill(null));
					}

					// Now we populate it with case data.
					for (const dateGeoData of dateCounts) {
						const dateOffset = moment(dateGeoData.date).diff(minDate, 'days');
						// Find and iterate over the objectIDs for this ZIP code
						for (const objectID of objectZIP[dateGeoData.ZIP.toString()]) {
							// Now write the number of cases to that cell.
							casesDateZIP[dateOffset][parseInt(objectID)] = dateGeoData.cases;					
						}
					}
					return casesDateZIP;
				}
				
			const positiveURL = "https://gis-public.sandiegocounty.gov/arcgis/rest/services/Hosted/COVID_19_Statistics_San_Diego_County/FeatureServer/0/query?where=1%3D1&outFields=objectid,date,tests,positives,newtests,newcases&returnGeometry=false&outSR=&f=json";
			d3.json(positiveURL).then(function(positiveRawData) {				
				const positiveData = [];
				for (let i = 0; i < positiveRawData.features.length; i++) {
					const thisRow = positiveRawData.features[i].attributes;
					const thisObject = {
						"date": parseInt(thisRow.date) / 1000,
						"tests": thisRow.tests,
						"newtests": thisRow.newtests,
						"positives": thisRow.positives,
						"newcases": thisRow.newcases,
						"cumPercentage": 100 * parseFloat(thisRow.positives) / parseFloat(Math.max(thisRow.tests, 1)),
						"todayPercent": (thisRow.newtests ? 100 * parseFloat(thisRow.newcases) / parseFloat(Math.max(thisRow.newtests, 1)) : null),
					};
					if (thisObject.tests !== null) {
						positiveData.push(thisObject);					
					}
				}
				
				// Ensure array is ordered by date
				positiveData.sort(function(a, b) {
					return a.date - b.date;
				});
				
				// Most recent information:
				const totalCases = positiveData[positiveData.length - 1].positives;
				const sinceYesterday = positiveData[positiveData.length - 1].newcases;
				const dataDate = positiveData[positiveData.length - 1].date;
				
				document.getElementById("overall-stats").innerHTML = "As of " +
				moment(1000 * parseInt(dataDate)).format('MMMM D, YYYY') + 
				", there were " + totalCases + " cases of COVID-19 recorded in San Diego County.<br>" +
				"This was an increase of " + sinceYesterday + " cases from the previous day.";
				document.getElementById("overall-stats").style.visibility = "visible";
								
				// Time is terrible. I hate it.
				const parseTime = d3.timeParse("%s");
								
				const xScale = d3
					.scaleTime()
					.domain([
						d3.min(positiveData, function(d) {
							return parseTime(d.date);
						}),
						d3.max(positiveData, function(d) {
							return parseTime(d.date);
						}),
					])
					.range([paddingPos, w - paddingPos]);
					
				const xAxis = d3.axisBottom(xScale);

				// Plotting two things; might need to know the largest-est
				const cumMax = d3.max(positiveData, function(d) {
					return d.cumPercentage;
				});
				const dailyMax = d3.max(positiveData, function(d) {
					return d.todayPercent;
				});
				const overallMax = Math.max(cumMax, dailyMax);			
				
				// y-axis doesn't need conversion, just move points away from margins
				// The 5 is an ad hoc constant to make things look better in Chrome
				const yScale = d3
					.scaleLinear()
					.domain([0, dailyMax])
					.range([hPositive - paddingPos, 5]);

				const yAxis = d3.axisLeft(yScale);

				const yScale2 = d3
					.scaleLinear()
					.domain([0, cumMax])
					.range([hPositive - paddingPos, 5]);

				const yAxis2 = d3.axisLeft(yScale2);

				const mouseOver = function(d) {
					d3.select(this)
						.style("fill", "#990000");
					tooltip
						.style("opacity", 1)
						.html(function() {
							return (
								moment(1000 * parseInt(d.date)).format('MMMM D, YYYY') + 
								"<br>" + (d.todayPercent ? d.todayPercent.toFixed(2) + "%<br>" + 
								d.newcases + " out of " + d.newtests + " tests" : "missing some data")
							);
						})
						.style("position", "absolute")
						.style("left", parseInt(d3.event.pageX) + "px")
						.style("top", parseInt(d3.event.pageY) + "px");
						d3.event.stopPropagation();
				}

				// Too lazy to do this the right way. Sorry not sorry.
				// When I'm getting paid, I'll avoid this sort of duplication.
				// I'll also separate things out instead of making one huge file.
				const mouseOver2 = function(d) {
					d3.select(this)
						.style("fill", "#990000");
					tooltip
						.style("opacity", 1)
						.html(function() {
							return (
								moment(1000 * parseInt(d.date)).format('MMMM D, YYYY') + 
								"<br>" + d.cumPercentage.toFixed(2) + "%<br>" + 
								d.positives + " out of " + d.tests + " tests"
							);
						})
						.style("position", "absolute")
						.style("left", parseInt(d3.event.pageX) + "px")
						.style("top", parseInt(d3.event.pageY) + "px");
						d3.event.stopPropagation();
				}

				const mouseLeave = function(d) {
					d3.select(this)
						.style("fill", "black");
					tooltip.style("opacity", 0);
				}

				// Let's make a graph!

				// Remove the loading text
				d3.select("#pos-loading-text").remove()

				// Positive cases by date
				positivesvg.selectAll("circle")
					.data(positiveData)
					.enter()
					.append("circle")
					.filter(function(d) {
						return (d.todayPercent !== null);
					})
					.attr("class", "point")
					.attr("fill", "black")
					.attr("cx", function(d) {
						return xScale(parseTime(d.date));											
					})
					.attr("cy", function (d) {
						return yScale(d.todayPercent)
					})
					.attr("r", 4)
					.on("mouseover", mouseOver)
					.on("click", mouseOver)
					.on("mouseleave", mouseLeave);
					
				positivesvg
					.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(0," + (hPositive - paddingPos) + ")")
					.call(xAxis);

				positivesvg
					.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(" + paddingPos + ",0)")
					.call(yAxis);

				// Remove the loading text
				d3.select("#cp-loading-text").remove()
										
				cumPositivesvg.selectAll("circle")
					.data(positiveData)
					.enter()
					.append("circle")
					.attr("class", "point")
					.attr("fill", "black")
					.attr("cx", function(d) {
						return xScale(parseTime(d.date));
					})
					.attr("cy", function (d) {
						return yScale2(d.cumPercentage)
					})
					.attr("r", 4)
					.on("mouseover", mouseOver2)
					.on("click", mouseOver2)
					.on("mouseleave", mouseLeave);		

				cumPositivesvg
					.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(0," + (hPositive - paddingPos) + ")")
					.call(xAxis);

				cumPositivesvg
					.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(" + paddingPos + ",0)")
					.call(yAxis2);
				
			// This is the closing delimiter for the percentage graphs
			// Note to self: Please stop deleting it.
			});


			// Use local copy of data for development.
// 			const url = "countyData.json";
			const url = "https://opendata.arcgis.com/datasets/854d7e48e3dc451aa93b9daf82789089_0.geojson";
			d3.json(url).then(function(countyData) {				
				dateCounts = processCountyData(countyData);

				// What dates do we have data for? What is the extent?
				const observedDate = dateCounts.map(function(observation) {
					return observation.date;
				});
				const minDate = moment.min(observedDate);
				const maxDate = moment.max(observedDate);
				const dateExtent = parseInt(maxDate.diff(minDate, 'days'));

				// Initialize the date picker.
				document.getElementById("zipDate").setAttribute("min", moment(minDate).format("YYYY-MM-DD"));		
				document.getElementById("zipDate").setAttribute("max", moment(maxDate).format("YYYY-MM-DD"));		
				document.getElementById("zipDate").setAttribute("value", moment(maxDate).format("YYYY-MM-DD"));		

				const mapData = makeMappableData(minDate, dateExtent, dateCounts, objectZIP);
				
		
				// max for ZIPs with more than five cases and more than 10,000 people
				const maxPer10k = d3.max(zipShapes.features, function(d, i) {
					return (mapData[dateExtent][i] > 4 && d.properties.population > 10000 ? 10000.0 * mapData[dateExtent][i] / Math.max(d.properties.population, 1) : 0);
				});
								
				// based on the case counts, define some colors
				// The magic number seven (plus or minus two)
				const colorScale = d3.scaleQuantize();
				colorScale.domain([0, maxPer10k]);
				colorScale.range(['#fef0d9', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#990000']);

				// Use gray for ZIPs with fewer than five cases
				const drabberScale = d3.scaleQuantize();
				drabberScale.domain([0, maxPer10k]);
				drabberScale.range(['#f7f7f7', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525']);

				d3.select("#zipDate")
					.on("change", function() {
						let chosenDate = moment(document.getElementById("zipDate").value);
						let chosenOffset = moment(chosenDate).diff(minDate, "days");
						if (chosenOffset < 0 || !(moment(chosenDate).isValid()) || moment(chosenDate).isAfter(moment())) {
							chosenDate = maxDate;
							chosenOffset = dateExtent;
							document.getElementById("zipDate").value = maxDate.format("YYYY-MM-DD");					
						}

						// Remove the loading text
						d3.select("#map-loading-text").remove();
						
						// Remove any old maps
						d3.selectAll("path.ZIP").remove();
				
						// Some words
						document.getElementById("words").innerHTML = "Data from " +
						chosenDate.format('MMMM D, YYYY') + ".";
						

						const mouseOver = function(d, i) {
							d3.select(this)
								.style("stroke-width", 1)
								.style("fill-opacity", 0.5);
							tooltip
								.style("opacity", 1)
								.html(function() {
									return (
										d.properties.ZIP + 
										" " + 
										(d.properties.ZIP === 92145 ? "MCAS Miramar" : d.properties.COMMUNITY)	+ 
										"<br>" +
										(mapData[chosenOffset][i] ? mapData[chosenOffset][i] : "no reported" ) +
										" case" +
										(mapData[chosenOffset][i] === 1 ? "" : "s") + 
										(mapData[chosenOffset][i] ? ", population: " + d.properties.population + "<br>" + (10000.0 * mapData[chosenOffset][i] / d.properties.population).toFixed(2) + " per 10k population" : "")
									);
								})
								.style("position", "absolute")
								.style("left", parseInt(d3.event.pageX) + "px")
								.style("top", parseInt(d3.event.pageY) + "px");
							d3.event.stopPropagation();
						}
				
						const mouseLeave = function(d) {
							d3.select(this)
								.style("stroke-width", 1)
								.style("fill-opacity", 1);
							tooltip.style("opacity", 0);
						}
	
						let path = d3.geoPath()
						 .projection(d3.geoMercator().fitSize([w, h], zipShapes));								
			
						// Bind data and create one path per GeoJSON feature
						mapsvg.selectAll("path")
							 .data(zipShapes.features)
							 .enter()
							 .append("path")
							 .attr("d", path)
							 .attr("class", function(d) { return "ZIP" })
							 .style("stroke", "black")
							 .style("fill", function(d, i) {
								const value = (10000 * mapData[chosenOffset][i] / Math.max(d.properties.population, 1));
								if (mapData[chosenOffset][i] > 4 && d.properties.population > 10000) {
									return colorScale(value);
								} else {
									return drabberScale(value ? value : 0);
								}
							 })
							 .on("click", mouseOver)
							 .on("mouseover", mouseOver)
							 .on("mouseleave", mouseLeave);		
					});

				document.getElementById("zipDate").dispatchEvent(new Event("change"));

			// End group for reading in the GeoJSON case data
			});
			
		</script>
	</body>
</html>
